---
status: pending
priority: p1
issue_id: "001"
tags: [code-review, security, data-integrity, critical]
dependencies: []
---

# CSV Injection Vulnerability in document_links Storage

## Problem Statement

The `document_links` field uses comma-separated storage without proper escaping, creating a critical CSV injection vulnerability. URLs containing commas will be parsed incorrectly, causing permanent data corruption. Additionally, malicious URLs could enable CSV injection attacks when exported.

**Why This Matters:** Users cannot store legitimate URLs with query parameters containing commas, and malicious actors could inject formula attacks via crafted URLs.

## Findings

### Security Review Agent
- **Severity:** CRITICAL
- **Location:** `src/models/task.py:116-118`
- **Risk:** CSV injection via formula characters (`=cmd|'/c calc'!A1`), data corruption from URLs with commas
- **Evidence:**
  ```python
  def set_document_links_list(self, links: list[str]) -> None:
      """Set document links from a list."""
      self.document_links = ",".join(links) if links else None
  ```

### Data Integrity Guardian
- **Severity:** CRITICAL
- **Location:** `src/models/task.py:110-118`
- **Scenario:** URL `https://example.com/doc?tags=work,urgent` gets split into `["https://example.com/doc?tags=work", "urgent"]`
- **Consequence:** Permanent data corruption, no recovery possible

## Proposed Solutions

### Solution 1: Migrate to JSON Storage (RECOMMENDED)
**Pros:**
- Handles all edge cases (commas, quotes, special characters)
- Standard format for structured data in string columns
- Better forward compatibility for adding metadata
- Backward compatible with fallback parsing

**Cons:**
- Requires database migration
- Slight performance overhead for JSON encode/decode
- Not human-readable in database

**Effort:** Medium (2-3 hours)
**Risk:** Low (backward compatible with migration)

**Implementation:**
```python
import json

def get_document_links_list(self) -> list[str]:
    """Get document links as a list."""
    if not self.document_links:
        return []
    try:
        return json.loads(self.document_links)
    except json.JSONDecodeError:
        # Fallback for legacy CSV format
        return [link.strip() for link in self.document_links.split(",") if link.strip()]

def set_document_links_list(self, links: list[str]) -> None:
    """Set document links from a list."""
    self.document_links = json.dumps(links) if links else None

# Migration:
# UPDATE tasks SET document_links = json_array(document_links) WHERE document_links IS NOT NULL;
```

### Solution 2: URL-Encode Commas Before Storage
**Pros:**
- Minimal code changes
- Maintains CSV format
- Human-readable in database

**Cons:**
- Still vulnerable to CSV formula injection
- Requires encoding/decoding on every access
- Complex edge case handling

**Effort:** Small (1 hour)
**Risk:** Medium (encoding bugs could corrupt data)

### Solution 3: Use Alternative Delimiter
**Pros:**
- Simple change
- Maintains simple parsing

**Cons:**
- ASCII record separator not human-readable
- Still vulnerable to injection if delimiter appears in URL
- Doesn't solve formula injection

**Effort:** Small (30 minutes)
**Risk:** Low

## Recommended Action

**Implement Solution 1 (JSON Storage)** - This is the most robust long-term solution that eliminates CSV injection risks entirely and provides forward compatibility.

## Technical Details

**Affected Files:**
- `src/models/task.py` - CSV parsing helpers
- `alembic/versions/` - New migration to convert CSV â†’ JSON
- `tests/unit/test_task_model.py` - Add edge case tests

**Database Changes:**
```sql
-- Migration: Convert existing CSV to JSON
UPDATE tasks
SET document_links = json_array(document_links)
WHERE document_links IS NOT NULL AND document_links != '';

-- For SQLite, may need Python-based data migration
```

**Performance Impact:** Minimal - JSON parsing is fast for small arrays (<10 URLs)

## Acceptance Criteria

- [ ] URLs with commas in query parameters are stored and retrieved correctly
- [ ] CSV formula injection attacks (`=cmd`, `@SUM()`, etc.) are prevented
- [ ] Existing data migrated without loss
- [ ] Backward compatibility: old CSV format can be read (fallback)
- [ ] All existing tests pass
- [ ] New edge case tests added:
  - URL with comma in query params
  - URL with quotes
  - URL with newlines (rejected)
  - CSV formula injection attempts (sanitized or rejected)

## Work Log

### 2026-02-11 - Issue Identified
- Multi-agent code review identified CSV injection vulnerability
- Confirmed data corruption risk with comma-containing URLs
- Prioritized as P1 (blocks merge)

## Resources

- **PR:** #2 - feat: Add external document links to tasks
- **Related Issue:** CSV injection in tags field (same pattern)
- **Security Reference:** [OWASP CSV Injection](https://owasp.org/www-community/attacks/CSV_Injection)
- **Similar Pattern:** `tags` field uses same vulnerable CSV approach
